            .global stereo_vision_sa
             ; DONE: Complete stereo vision function in linear assembly
             ; TODO: Optimise linear assembly. Target: <0.04s, Current: 0.0492s
             ; Ideas:
             ; Balance functional units for both A and B sides.
             ; Draw dependency graph to find areas to fix.
             ; Optimise either the arithmetic part or the data parts.
stereo_vision_sa  .cproc a_1,a_2,a_3,a_4,a_5
									.reg i, j, k, sum, minimize, distance, width
									.reg check, sum_check, mult_one, and_one, const_minimize
									.reg w1, w2, w3, w4, w5, w6, w7, w8, w9, w10
									.reg w11, w12, w13, w14, w15, w16, w17, w18, w19, w20
									.reg offsetL1, offsetL2, offsetL3, offsetL4, offsetL5
									.reg maxWidth, maxHeight
									.reg index

									MVKL 276, maxWidth
									MVKL 219, maxHeight
									MVKL 0x000000FF, and_one
									MVKL 280, width
									MVKL 0x86A0, const_minimize;
									MVKH 1, const_minimize;
									MVKL 0x01010101, mult_one
                  MVKH 0x01010101, mult_one
                  ZERO i; Loop variable i
; Begin loop i
loopi							ZERO j; Loop variable j
; Begin loop j
loopj							ZERO distance;
									MV const_minimize, minimize

									ZERO k

									ADD i, 1, offsetL2
									ADD i, 2, offsetL3
									ADD i, 3, offsetL4
									ADD i, 4, offsetL5
									MPY i, width, offsetL1
									MPY width, offsetL2, offsetL2
									MPY width, offsetL3, offsetL3
									MPY width, offsetL4, offsetL4
									MPY width, offsetL5, offsetL5
									ADD j, offsetL1, offsetL1
									ADD j, offsetL2, offsetL2
									ADD j, offsetL3, offsetL3
									ADD j, offsetL4, offsetL4
									ADD j, offsetL5, offsetL5

									LDNDW *a_1(offsetL1), w1:w2
									LDNDW *a_1(offsetL2), w3:w4
									LDNDW *a_1(offsetL3), w5:w6
									LDNDW *a_1(offsetL4), w7:w8
                  LDNDW *a_1(offsetL5), w9:w10
                  AND and_one, w1, w1
                  AND and_one, w3, w3
                  AND and_one, w5, w5
                  AND and_one, w7, w7
                  AND and_one, w9, w9
; Begin loop k
loopk							ZERO sum

									SUB offsetL1, k, index
                  LDNDW *a_2(index), w11:w12
                  AND and_one, w11, w11

									SUB offsetL2, k, index
									LDNDW *a_2(index), w13:w14
                  AND and_one, w13, w13
									
									SUB offsetL3, k, index
									LDNDW *a_2(index), w15:w16
                  AND and_one, w15, w15
									
									SUB offsetL4, k, index
									LDNDW *a_2(index), w17:w18
                  AND and_one, w17, w17
                  
									SUB offsetL5, k, index
									LDNDW *a_2(index), w19:w20
                  AND and_one, w19, w19

									; It's possible to reuse words for calculations.
									; The reason it didn't work before is because I
									; used the wrong words. Using the left side words
									; breaks everything. Using the right side words shouldn't.
									SUB w1, w11, w11
									SUB w3, w13, w13
									SUB w5, w15, w15
									SUB w7, w17, w17
									SUB w9, w19, w19

									ABS w11, w11
									ABS w13, w13
									ABS w15, w15
									ABS w17, w17
									ABS w19, w19

									SUBABS4 w2, w12, w12
									SUBABS4 w4, w14, w14
									SUBABS4 w6, w16, w16
									SUBABS4 w8, w18, w18
									SUBABS4 w10, w20, w20

									DOTPU4 mult_one, w12, w12
									DOTPU4 mult_one, w14, w14
									DOTPU4 mult_one, w16, w16
									DOTPU4 mult_one, w18, w18
									DOTPU4 mult_one, w20, w20

									ADD w11, w12, w12
									ADD w13, w14, w14
									ADD w12, w14, sum

									ADD w15, w16, w16
									ADD w17, w18, w18
									ADD w16, w18, w18

									ADD w19, w20, w20
									ADD w18, w20, w20
									ADD w20, sum, sum

									CMPLT j, k, check; j < k
									XOR 1, check, check; j >= k
			 					 	CMPLT sum, minimize, sum_check; sum < minimize
									AND sum_check, check, check; !(j < k) && (sum < minimize)

									; If check == 0, then minimize := 0. 0 + sum := minimize is now
									; equivalent to a conditional MV sum, minimize.
									; If check == 1, then minimize := 100,000. 100,000 + sum := minimize.
									; Since the goal is to minimize sum, this is fine.
									MPY check, const_minimize, minimize
									ADD sum, minimize, minimize

									MV sum, minimize
									; If check == 0, then k * 0 == 0 := distance, else k * 1 == k := distance.
									; This is because distance defaults to 0, so keeping its previous value
									; should be equivalent to zeroing it.
									MPY check, k, distance

									ADD k, 1, k
									CMPLT k, a_4, check
				[check]  	B loopk
; End loop k
									ADD i, a_5, index
									MPY width, index, index
									ADD j, index, index
									ADD a_5, index, index
									STB distance, *a_3[index]

									ADD j, 1, j
                  CMPLT j, maxWidth, check
				[check]  	B loopj
; End loop j
                  ADD i, 1, i
                  CMPLT i, maxHeight, check
				[check]  	B loopi
; End loop i
                  .return
                  .endproc
